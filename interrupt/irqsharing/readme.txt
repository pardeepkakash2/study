The Process : Another name for a process is a task ie: struct task_struct (struct thread_info).	

processes include a set of resources:

	Open files
	Pending signals
	Internal kernel data
	Processor state
	Memory address space with one or more memory mappings
	Thread(s) of execution
	Data section containing global variables

Threads of execution :
Threads of execution, often shortened to threads, are the objects of activity within the process.
Each thread includes:
	Program counter
	Process stack
	Set of processor registers

The kernel schedules individual threads, not processes. Linux does not differentiate between threads and processes. 
To Linux, a thread is just a special kind of process.

Virtualized processor and virtual memory :

virtual processor : gives the process the illusion that it alone monopolizes the system, 
	despite possibly sharing the processor among hundreds of other processes. 
Virtual memory : lets the process allocate and manage memory as if it alone owned all the memory in the system

Note : Threads share the virtual memory abstraction, whereas each receives its own virtualized processor.

Life of a process :
A process is an active program and related resources:
    Two or more processes can exist that are executing the same program.
    Two or more processes can exist that share various resources, such as open files or an address space.

fork, exec, exit and wait :

In Linux, the fork() system call creates a new process by duplicating an existing one.
    The process that calls fork() is the parent, whereas the new process is the child.
    The parent resumes execution and the child starts execution at the same place: where the call to fork() returns.
    The fork() system call returns from the kernel twice: once in the parent process and again in the newborn child.

The exec() family of function calls creates a new address space and loads a new program into the newborn child immediately after a fork. 
In contemporary Linux kernels, fork() is actually implemented via the clone() system call, which is discussed in a following section.

The exit() system call terminates the process and frees all its resources. A parent process can inquire about the status of a terminated 
child via the wait4() system call. A process can wait for the termination of a specific process. 
When a process exits, it is placed into a special zombie state that represents terminated processes until the parent 
calls wait() or waitpid(). 

Kernel Threads :
	Kernel threads are standard processes that exist solely in kernel-space. 
	They are useful for the kernel to perform some operations in the background.

Difference from normal threads:
    Kernel threads do not have an address space. Their mm pointer, which points at their address space, is NULL.
    Kernel threads operate only in kernel-space and do not context switch into user-space.

Similarity with normal threads:
    Kernel threads are schedulable and preemptable.

	Kernel threads are created on system boot by other kernel threads.
	A kernel thread can be created only by another kernel thread. The kernel handles this automatically by forking 
		all new kernel threads off of the kthreadd kernel process.

create kernel thread :
	struct task_struct *kthread_create(int (*threadfn)(void *data),
                                   void *data,
                                   const char namefmt[],
                                   ...)

    The new process will run the threadfn function, which is passed the data argument.
    The process will be named namefmt, which takes printf-style formatting arguments in the variable argument list.
    The process is created in an unrunnable state; it will not start running until explicitly woken up via wake_up_process().

A process can be created and made runnable with a single function, kthread_run():

struct task_struct *kthread_run(int (*threadfn)(void *data),
                                void *data,
                                const char namefmt[],
                                ...)
stop the kernel thread :
	int kthread_stop(struct task_struct *k)

http://learnlinuxconcepts.blogspot.in/2014/01/bottom-halves.html
https://notes.shichao.io/lkd/ch8/
http://wiki.dreamrunner.org/public_html/BooksReview/Linux%20DeviceDrivers/LinuxDeviceDriversNotes.html

what is interrupt and why we should we use it ?
	1. Interrupts enable hardware to signal to the processor.
	2. Hardware devices generate interrupts asynchronously (with respect to the processor clock).
	3. These interrupt values are often called interrupt request (IRQ) lines.

How can the processor work with hardware without impacting the machine's overall performance? 

Exceptions and Interrupts ?
Interrupts: 
	asynchronous interrupts generated by hardware.
Exceptions: 
	synchronous interrupts generated by the processor.

what is ISR and interrupt handler ?
An interrupt handler or interrupt service routine (ISR) is the function that the kernel runs in response to a specific interrupt:

1. Each device that generates interrupts has an associated interrupt handler.
2. The interrupt handler for a device is part of the device's driver (the kernel code that manages the device).

Top Halves Versus Bottom Halves ?
Top half : 
	The interrupt handler is the top half. The top half is run immediately upon receipt of the interrupt 
	and performs only the work that is time-critical, such as acknowledging receipt of the interrupt or resetting the hardware.
Bottom half: 
	Work that can be performed later is deferred until the bottom half. The bottom half runs in the future, 
	at a more convenient time, with all interrupts enabled.

What are the bottom halves being used in the present linux kernels?
1. softirq 
2. tasklet
3. workqueue

softirq :
1. Softirqs are statically allocated at compile-time. So there are fixed number of softirq and they run in priority order.
2. Softirqs have strong CPU affinity, so they are reserved for most of time critical and important bottom half processing on the system.
3. softirq is guaranteed to run on the CPU it was scheduled on in SMP systems.
4. It Runs in interrupt context, so Interrupt context cannot perform certain actions that can result in the kernel putting 
	the current context to sleep, such as downing a semaphore, copying to or from user-space memory or non-atomically allocating memory
5. it can’t preempted and can’t scheduled ie: A softirq never preempts another softirq.
	 The only event that can preempt a softirq is an interrupt handler.
6. Atomic execution
7. it can run simultaneously on one or more processor, even two of the same type of softirq can run concurrently

Note : Currently, only two subsystems directly use softirqs: Networking devices and Block devices
Additionally, kernel timers and tasklets are built on top of softirqs.

Note : Softirqs are most often raised from within interrupt handlers. 
	First the interrupt handler(top half) performs the basic hardware-related work, raises the softirq, and then exits. 
	After the kernel is done processing interrupts, it checks wither any of the softirqs have been raised or not.
	 Code flow in Linux kernel for interrupt handling is explained below.

Interrupt 

 | do_IRQ()  (top half which masks all interrupts and invoke softirq)

   | irq_exit() (Release all masked interrupts)

     | invoke_softirq() (Kernel checks for the any pending invoked irq)

       | do_softirq() (Execution of softirq (bottom half) with )

Softirqs are represented by the softirq_action.

struct softirq_action
{
    void    (*action)(struct softirq_action *);
};

static struct softirq_action softirq_vec[NR_SOFTIRQS];

The Softirq Handler :
void softirq_handler(struct softirq_action *);

The following table contains a list of the existing softirq types.

Tasklet 	Priority 	Softirq Description
HI_SOFTIRQ 	0 		High-priority tasklets
TIMER_SOFTIRQ 	1 		Timers
NET_TX_SOFTIRQ 	2 		Send network packets
NET_RX_SOFTIRQ 	3 		Receive network packets
BLOCK_SOFTIRQ 	4 		Block devices
TASKLET_SOFTIRQ 5 		Normal priority tasklets
SCHED_SOFTIRQ 	6 		Scheduler
HRTIMER_SOFTIRQ 7 		High-resolution timers
RCU_SOFTIRQ 	8 		RCU locking

Raising Your Softirq :
	raise_softirq(NET_TX_SOFTIRQ);

Tasklet :
	Tasklets are build on top of softirq. The central idea of tasklet is to provide rich bottom half mechanisum. 
	Only below points diffres from softirq.

1. Tasklets have a weaker CPU affinity than softirqs
2. Unlike softirqs, tasklets are dynamically allocated.
3. A tasklet can run on only one CPU at a time.
4. Runs in interrupt contex, Interrupt context cannot perform certain actions that can result in the kernel putting 
	the current context to sleep, such as downing a semaphore, copying to or from user-space memory or non-atomically allocating memory
5. Atomic execution
6. Two different tasklets can run concurrently on different processors, but two of the same type of tasklet cannot run 
	simultaneously on same processor.
7. Tasklet is strictly serialized wrt itself, but not wrt another tasklets.
8. Tasklet runs on same CPU from where is raised

Declaration : 
Both these macros statically create a struct tasklet_struct with the given name :
DECLARE_TASKLET(name, func, data)
DECLARE_TASKLET_DISABLED(name, func, data);

Writing Your Tasklet Handler :
	void tasklet_handler(unsigned long data);

Scheduling Your Tasklet :
	tasklet_schedule(&my_tasklet); /* mark my_tasklet as pending */

enable and disable tasklet :
	tasklet_enable(), tasklet_diaable(),tasklet_disable_nosync()

ksoftirqd :
	There is one thread per processor, each named ksoftirqd/n where n is the processor number.



Workqueue :
Workqueues are also like tasklets. They are useful to schedule a task that for future. There is some identical difference between  two,
Runs in kenrel process context. Because work queues run in process context (kernel threads), they are capable of sleeping

1. Run in process contact ie. Non atomic execution
2. Workqueue runs on same CPU from where is raised
3. Higher latency compared to tasklet
4. Because work queues run in process context (kernel threads), they are capable of sleeping
5. alternative to work queues is kernel threads

Creating Work :
	staticaly : DECLARE_WORK(name, void (*func)(void *), void *data);
	dynamicaly : INIT_WORK(struct work_struct *work, void (*func)(void *), void *data);

Your Work Queue Handler :
	void work_handler(void *data)

Scheduling Work :
	schedule_work(&work), schedule_delayed_work(&work, delay);

Flushing Work : 
	void flush_scheduled_work(void);
	int cancel_delayed_work(struct work_struct *work);

creating New Work Queues :
	struct workqueue_struct *create_workqueue(const char *name);
	eg. struct workqueue_struct *keventd_wq;
	keventd_wq = create_workqueue("events");

flush workqueue :
	flush_workqueue(struct workqueue_struct *wq)


Tasklets Vs SoftIrqs and Why softIRQ if tasklet is there ??

Tasklets and SoftIrqs are two ways to implement bottom halves ( and definitely not the only two ways).
Tasklets are dynamically created and are simpler to use. So while deciding upon which one to use , 
go for tasklets unless the work is time critical. Networking and Block devices, whose work is time critical use SoftIrqs.

SoftIrqs Vs Tasklets Vs WorkQueues ?

1. Deferred work runs in Interrupt context in case of SoftIrqs and Tasklets while it runs in process context in case of workqueues.
2. SoftIrqs(same or different) can run run simulatenously on different processor cores ; 
	same Tasklets can't run simultaneously on different CPU cores but different Tasklets definitely can; 
	workqueues can run of different CPU cores simultaneously.
3. As SoftIrqs and Tasklets run in interrupt context they can't sleep while workqueues can sleep as they run in the process context.
4. Both SoftIrqs and Tasklets can't be preempted or scheduled while Workqueues can be.
5. SoftIrqs are not easy to use while Tasklets and WorkQueues are easy to use.
6. If the code in question is highly threaded( too many subroutines) for ex. Networking applications 
	then SoftIrq is the best bet as they are the fastest.
7. If the code is not highly threaded then the device driver developer must go for Tasklets as they have the simplest interface.
8. If the deferred work has to run in the process context then WorkQueues is the only option.
9. So, in general if your bottom halve can sleep then use WorkQueues else use Tasklets.
10. When it comes to ease of use WorkQueues are the best then comes tasklets and in the end comes softirqs 
	as they have to be statically created and require proper thinking before implementing.

For example using the network card:

1. When network cards receive packets from the network, the network cards immediately issue an interrupt. 
	This optimizes network throughput and latency and avoids timeouts.
2. The kernel responds by executing the network card's registered interrupt.
3. The interrupt runs, acknowledges the hardware, copies the new networking packets into main memory, 
	and readies the network card for more packets. These jobs are the important, time-critical, and hardware-specific work.
	a. The kernel generally needs to quickly copy the networking packet into main memory because the network data buffer 
		on the networking card is fixed and miniscule in size, particularly compared to main memory. 
		Delays in copying the packets can result in a buffer overrun, with incoming packets overwhelming 
		the networking card's buffer and thus packets being dropped.
        b. After the networking data is safely in the main memory, the interrupt's job is done, and it can return control 
		of the system to whatever code was interrupted when the interrupt was generated.
4. The rest of the processing and handling of the packets occurs later, in the bottom half

include/linux/interrupt.h#L80
/* request_irq: allocate a given interrupt line */
int request_irq(unsigned int irqn,irq_handler_t handler, unsigned long flags, const char *name, void *dev);

	irqn is the requested interrupt line
	my_interrupt is the handler;
	IRQF_SHARED specifies that the line can be shared;
	The device is named my_device;
	We passed my_dev for dev.

/*interrupt handler*/
typedef irqreturn_t (*irq_handler_t)(int, void *);
static irqreturn_t intr_handler(int irq, void *dev)
{
	return IRQ_HANDLED;
}

/*Freeing an Interrupt Handler*/
void free_irq(unsigned int irq, void *dev);
Note : A call to free_irq() must be made from process context.

Reentrancy and Interrupt Handlers ?
Shared Handlers ?
nested interrupts ?
Real-Life Interrupt Handle ?
	The real-time clock (RTC) driver is a real interrupt handler, which can be found in drivers/char/rtc.c.
	
	It is a device (separate from the system timer) which can do the following:
		Sets the system clock.
		Provides an alarm.
		Supplies a periodic timer.

Difference from the process context and interrupt context?
process context :
	is the mode of operation the kernel is in while it is executing on behalf of a process, 
	such as executing a system call or running a kernel thread.

	1. In process context, the current macro points to the associated task.
	2. Since a process is coupled to the kernel in process context, process context can sleep or otherwise invoke the scheduler.

Interrupt context : is not associated with a process.

	1 .The current macro is not relevant, though it points to the interrupted process.
		Without a backing process, interrupt context cannot sleep and cannot reschedule. 
	2. Therefore, you cannot call certain functions from interrupt context. If a function sleeps, 
		you cannot use it from your interrupt handler: this limits the functions that can be called from an interrupt handler
	3. Interrupt context is time-critical, because the interrupt handler interrupts other code.
		so As much as possible, work should be pushed out from the interrupt handler and performed in a bottom half, 
		which runs at a more convenient time.

Stacks of an interrupt handler ?
	1. interrupt handlers did not receive their own stacks. Instead, they would share the stack of the process that they interrupted.
	2. The kernel stack is two pages in size:
		8KB on 32-bit architectures.
		16KB on 64-bit architectures.
	3. Because of sharing the stack, interrupt handlers must be exceptionally frugal with what data they allocate there.
	4. Your interrupt handler should not care what stack setup is in use or what the size of the kernel stack is. 
		Always use an absolute minimum amount of stack space

virtual filesystem for interrupts ?
	/proc/interrupts.

Interrupt Control and Disabling and Enabling Interrupts ?
Controlling the interrupt system provides synchronization.

1. Disabling interrupts guarantees that an interrupt handler will not preempt the current code.
2. Disabling interrupts disables kernel preemption and provides protection against concurrent access from a possible interrupt handler..

local_irq_disable();
/* interrupts are disabled .. */
local_irq_enable();

prefeared way ?
unsigned long flags;
local_irq_save(flags); /* interrupts are now disabled */
/* ... */
local_irq_restore(flags); /* interrupts are restored to their previous state */

Disabling a Specific Interrupt Line ?
void disable_irq(unsigned int irq);
void disable_irq_nosync(unsigned int irq);
void enable_irq(unsigned int irq);
void synchronize_irq(unsigned int irq);

Status of the Interrupt System ?
	The macro irqs_disabled(), defined in <asm/system.h>, returns nonzero if the interrupt system on the local processor is disabled. 
	Otherwise, it returns zero.

kernel's current context ?

	in_interrupt()
	in_irq()

Function 		Description
local_irq_disable() 	Disables local interrupt delivery
local_irq_enable() 	Enables local interrupt delivery
local_irq_save() 	Saves the current state of local interrupt delivery and then disables it
local_irq_restore() 	Restores local interrupt delivery to the given state
disable_irq() 		Disables the given interrupt line and ensures no handler on the line is executing before returning
disable_irq_nosync() 	Disables the given interrupt line
enable_irq() 		Enables the given interrupt line
irqs_disabled() 	Returns nonzero if local interrupt delivery is disabled; otherwise returns zero
in_interrupt() 		Returns nonzero if in interrupt context and zero if in process context
in_irq() 		Returns nonzero if currently executing an interrupt handler and zero otherwis

Note : The interrupt handler is normally static because it is never called directly from another file.

conclusion :
Work performed in interrupts includes:

    Acknowledging and resetting hardware
    Copying data from the device to main memory and vice versa
    Processing hardware requests
    Sending out new hardware requests

The kernel provides interfaces for:

    Registering and unregistering interrupt handlers
    Disabling interrupts
    Masking out interrupt lines
    Checking the status of the interrupt system


workqueue :
http://playopensuse.blogspot.in/2015/04/workqueue-mechanism-in-linux.html
https://lwn.net/Articles/23634/

Driver implementation :

Initialization
--------------
Set your gpio pin value: 0 or 1
Set your pin type, such as input or output
Set your interrupt type, such as trigger on rising edge, low level, high level, ...
If these are not set, they will take default values
Initialize your interrupt using: request_irq()


Opening Driver
--------------
When the driver is opened, enable your interrupt


Interrupt Handler
-----------------
Disable interrupt
Clear interrupt
Perform the work (best done by scheduling it to be done after exiting interrupt handler)
Enable interrupt


Close Driver
------------
Disable interrupt


Exit
----
Call free_irq()

Synchronization :

The kernel has causes of concurrency:

Interrupts:
	 An interrupt can occur asynchronously at almost any time, interrupting the currently executing code.
Softirqs and tasklets:
	 The kernel can raise or schedule a softirq or tasklet at almost any time, interrupting the currently executing code.
Kernel preemption:
	 Because the kernel is preemptive, one task in the kernel can preempt another.
Sleeping and synchronization with user-space:
	 A task in the kernel can sleep and thus invoke the scheduler, resulting in the running of a new process.
Symmetrical multiprocessing:
	 Two or more processors can execute kernel code at exactly the same time.

Kernel developers need to understand and prepare for these causes of concurrency:

	1. It is a major bug if an interrupt occurs in the middle of code that is manipulating a resource 
		and the interrupt handler can access the same resource.
	2. Similarly, it is a bug if kernel code is preemptive while it is accessing a shared resource.
	3. Likewise, it is a bug if code in the kernel sleeps while in the middle of a critical section.
	4. Finally, two processors should never simultaneously access the same piece of data.


knowing What to Protect:
	1.Obviously, any data that is local to one particular thread of execution does not need protection, 
		because only that thread can access the data. For example, local automatic variables 
		(and dynamically allocated data structures whose address is stored only on the stack) do not need any sort of locking 
		because they exist solely on the stack of the executing thread.
	2. Likewise, data that is accessed by only a specific task does not require locking 
		(because a process can execute on only one processor at a time)
	
Ask yourself these questions whenever you write kernel code:

1. Is the data global? Can a thread of execution other than the current one access it?
2. Is the data shared between process context and interrupt context? Is it shared between two different interrupt handlers?
3. If a process is preempted while accessing this data, can the newly scheduled process access the same data?
4. Can the current process sleep (block) on anything? If it does, in what state does that leave any shared data?
5. What prevents the data from being freed out from under me?
6. What happens if this function is called again on another processor?
7. Given the proceeding points, how am I going to ensure that my code is safe from concurrency?

Note : all global and shared data in the kernel requires some form of the synchronization methods

Deadlocks:

A deadlock is a condition involving one or more threads of execution and one or more resources, 
such that each thread waits for one of the resources, but all the resources are already held. 
The threads all wait for each other, but they never make any progress toward releasing the resources that they already hold. 
Therefore, none of the threads can continue, which results in a deadlock.

Note : The simplest example of a deadlock is the self-deadlock.
	solution : recursive lock.

Starvation :

	

Atomin Bitwise 
void set_bit(int nr, void *addr) 		Atomically set the nr-th bit starting from addr.
void clear_bit(int nr, void *addr) 		Atomically clear the nr-th bit starting from addr.
void change_bit(int nr, void *addr) 		Atomically flip the value of the nr-th bit starting from addr.
int test_and_set_bit(int nr, void *addr) 	Atomically set the nr-th bit starting from addr and return the previous value.
int test_and_clear_bit(int nr, void *addr) 	Atomically clear the nr-th bit starting from addr and return the previous value.
int test_and_change_bit(int nr, void *addr) 	Atomically flip the nr-th bit starting from addr and return the previous value.
int test_bit(int nr, void *addr) 		Atomically return the value of the nr-th bit starting from addr

int find_first_bit(unsigned long *addr, unsigned int size)
int find_first_zero_bit(unsigned long *addr, unsigned int size)

spinlock :

Mutex:

Kernel Data Structures :
	linklist:
	queaue :i

linklist: Singly and Doubly Linked Lists and circuler linklist.

single :	
/* an element in a linked list */
struct list_element {
    void *data; /* the payload */
    struct list_element *next; /* pointer to the next element */
};

doubley :
/* an element in a linked list */
struct list_element {
    void *data; /* the payload */
    struct list_element *next; /* pointer to the next element */
    struct list_element *prev; /* pointer to the previous element */
};

Using the macro container_of(), we can easily find the parent structure containing any given member variable. 
In C, the offset of a given variable into a structure is fixed by the ABI at compile time.
#define container_of(ptr, type, member) ({ \
        const typeof( ((type *)0)->member ) *__mptr = (ptr); \
        (type *)( (char *)__mptr - offsetof(type,member) );})


