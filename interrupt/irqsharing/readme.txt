http://learnlinuxconcepts.blogspot.in/2014/01/bottom-halves.html
https://notes.shichao.io/lkd/ch8/
http://wiki.dreamrunner.org/public_html/BooksReview/Linux%20DeviceDrivers/LinuxDeviceDriversNotes.html

what is interrupt and why we should we use it ?
	1. Interrupts enable hardware to signal to the processor.
	2. Hardware devices generate interrupts asynchronously (with respect to the processor clock).
	3. These interrupt values are often called interrupt request (IRQ) lines.

How can the processor work with hardware without impacting the machine's overall performance? 

Exceptions and Interrupts ?
Interrupts: 
	asynchronous interrupts generated by hardware.
Exceptions: 
	synchronous interrupts generated by the processor.

what is ISR and interrupt handler ?
An interrupt handler or interrupt service routine (ISR) is the function that the kernel runs in response to a specific interrupt:

1. Each device that generates interrupts has an associated interrupt handler.
2. The interrupt handler for a device is part of the device's driver (the kernel code that manages the device).

Top Halves Versus Bottom Halves ?
Top half : 
	The interrupt handler is the top half. The top half is run immediately upon receipt of the interrupt 
	and performs only the work that is time-critical, such as acknowledging receipt of the interrupt or resetting the hardware.
Bottom half: 
	Work that can be performed later is deferred until the bottom half. The bottom half runs in the future, 
	at a more convenient time, with all interrupts enabled.

What are the bottom halves being used in the present linux kernels?
1. softirq 
2. tasklet
3. workqueue

softirq :
1. Softirqs are statically allocated at compile-time. So there are fixed number of softirq and they run in priority order.
2. Softirqs have strong CPU affinity, so they are reserved for most of time critical and important bottom half processing on the system.
3. softirq is guaranteed to run on the CPU it was scheduled on in SMP systems.
4. It Runs in interrupt context, so Interrupt context cannot perform certain actions that can result in the kernel putting 
	the current context to sleep, such as downing a semaphore, copying to or from user-space memory or non-atomically allocating memory
5. it can’t preempted and can’t scheduled
6. Atomic execution
7. it can run simultaneously on one or more processor, even two of the same type of softirq can run concurrently

Note : Softirqs are most often raised from within interrupt handlers. 
	First the interrupt handler(top half) performs the basic hardware-related work, raises the softirq, and then exits. 
	After the kernel is done processing interrupts, it checks wither any of the softirqs have been raised or not.
	 Code flow in Linux kernel for interrupt handling is explained below.

Interrupt 

 | do_IRQ()  (top half which masks all interrupts and invoke softirq)

   | irq_exit() (Release all masked interrupts)

     | invoke_softirq() (Kernel checks for the any pending invoked irq)

       | do_softirq() (Execution of softirq (bottom half) with )

Tasklet :
	Tasklets are build on top of softirq. The central idea of tasklet is to provide rich bottom half mechanisum. 
	Only below points diffres from softirq.

1. Tasklets have a weaker CPU affinity than softirqs
2. Unlike softirqs, tasklets are dynamically allocated.
3. A tasklet can run on only one CPU at a time.
4. Runs in interrupt contex, Interrupt context cannot perform certain actions that can result in the kernel putting 
	the current context to sleep, such as downing a semaphore, copying to or from user-space memory or non-atomically allocating memory
5. Atomic execution
6. Two different tasklets can run concurrently on different processors, but two of the same type of tasklet cannot run 
	simultaneously on same processor.
7. Tasklet is strictly serialized wrt itself, but not wrt another tasklets.
8. Tasklet runs on same CPU from where is raised


Workqueue :
Workqueues are also like tasklets. They are useful to schedule a task that for future. There is some identical difference between  two,
Runs in kenrel process context. Because work queues run in process context (kernel threads), they are capable of sleeping

	Non atomic execution
	Workqueue runs on same CPU from where is raised
	Higher latency compared to tasklet

Tasklets Vs SoftIrqs and Why softIRQ if tasklet is there ??

Tasklets and SoftIrqs are two ways to implement bottom halves ( and definitely not the only two ways).
Tasklets are dynamically created and are simpler to use. So while deciding upon which one to use , 
go for tasklets unless the work is time critical. Networking and Block devices, whose work is time critical use SoftIrqs.

SoftIrqs Vs Tasklets Vs WorkQueues ?

1. Deferred work runs in Interrupt context in case of SoftIrqs and Tasklets while it runs in process context in case of workqueues.
2. SoftIrqs(same or different) can run run simulatenously on different processor cores ; 
	same Tasklets can't run simultaneously on different CPU cores but different Tasklets definitely can; 
	workqueues can run of different CPU cores simultaneously.
3. As SoftIrqs and Tasklets run in interrupt context they can't sleep while workqueues can sleep as they run in the process context.
4. Both SoftIrqs and Tasklets can't be preempted or scheduled while Workqueues can be.
5. SoftIrqs are not easy to use while Tasklets and WorkQueues are easy to use.
6. If the code in question is highly threaded( too many subroutines) for ex. Networking applications 
	then SoftIrq is the best bet as they are the fastest.
7. If the code is not highly threaded then the device driver developer must go for Tasklets as they have the simplest interface.
8. If the deferred work has to run in the process context then WorkQueues is the only option.
9. So, in general if your bottom halve can sleep then use WorkQueues else use Tasklets.
10. When it comes to ease of use WorkQueues are the best then comes tasklets and in the end comes softirqs 
	as they have to be statically created and require proper thinking before implementing.

For example using the network card:

1. When network cards receive packets from the network, the network cards immediately issue an interrupt. 
	This optimizes network throughput and latency and avoids timeouts.
2. The kernel responds by executing the network card's registered interrupt.
3. The interrupt runs, acknowledges the hardware, copies the new networking packets into main memory, 
	and readies the network card for more packets. These jobs are the important, time-critical, and hardware-specific work.
	a. The kernel generally needs to quickly copy the networking packet into main memory because the network data buffer 
		on the networking card is fixed and miniscule in size, particularly compared to main memory. 
		Delays in copying the packets can result in a buffer overrun, with incoming packets overwhelming 
		the networking card's buffer and thus packets being dropped.
        b. After the networking data is safely in the main memory, the interrupt's job is done, and it can return control 
		of the system to whatever code was interrupted when the interrupt was generated.
4. The rest of the processing and handling of the packets occurs later, in the bottom half

include/linux/interrupt.h#L80
/* request_irq: allocate a given interrupt line */
int request_irq(unsigned int irqn,irq_handler_t handler, unsigned long flags, const char *name, void *dev);

	irqn is the requested interrupt line
	my_interrupt is the handler;
	IRQF_SHARED specifies that the line can be shared;
	The device is named my_device;
	We passed my_dev for dev.

/*interrupt handler*/
typedef irqreturn_t (*irq_handler_t)(int, void *);
static irqreturn_t intr_handler(int irq, void *dev)
{
	return IRQ_HANDLED;
}

/*Freeing an Interrupt Handler*/
void free_irq(unsigned int irq, void *dev);
Note : A call to free_irq() must be made from process context.

Reentrancy and Interrupt Handlers ?
Shared Handlers ?
nested interrupts ?
Real-Life Interrupt Handle ?
	The real-time clock (RTC) driver is a real interrupt handler, which can be found in drivers/char/rtc.c.
	
	It is a device (separate from the system timer) which can do the following:
		Sets the system clock.
		Provides an alarm.
		Supplies a periodic timer.

Difference from the process context and interrupt context?
process context :
	is the mode of operation the kernel is in while it is executing on behalf of a process, 
	such as executing a system call or running a kernel thread.

	1. In process context, the current macro points to the associated task.
	2. Since a process is coupled to the kernel in process context, process context can sleep or otherwise invoke the scheduler.

Interrupt context : is not associated with a process.

	1 .The current macro is not relevant, though it points to the interrupted process.
		Without a backing process, interrupt context cannot sleep and cannot reschedule. 
	2. Therefore, you cannot call certain functions from interrupt context. If a function sleeps, 
		you cannot use it from your interrupt handler: this limits the functions that can be called from an interrupt handler
	3. Interrupt context is time-critical, because the interrupt handler interrupts other code.
		so As much as possible, work should be pushed out from the interrupt handler and performed in a bottom half, 
		which runs at a more convenient time.

Stacks of an interrupt handler ?
	1. interrupt handlers did not receive their own stacks. Instead, they would share the stack of the process that they interrupted.
	2. The kernel stack is two pages in size:
		8KB on 32-bit architectures.
		16KB on 64-bit architectures.
	3. Because of sharing the stack, interrupt handlers must be exceptionally frugal with what data they allocate there.
	4. Your interrupt handler should not care what stack setup is in use or what the size of the kernel stack is. 
		Always use an absolute minimum amount of stack space

virtual filesystem for interrupts ?
	/proc/interrupts.

Interrupt Control and Disabling and Enabling Interrupts ?
Controlling the interrupt system provides synchronization.

1. Disabling interrupts guarantees that an interrupt handler will not preempt the current code.
2. Disabling interrupts disables kernel preemption and provides protection against concurrent access from a possible interrupt handler..

local_irq_disable();
/* interrupts are disabled .. */
local_irq_enable();

prefeared way ?
unsigned long flags;
local_irq_save(flags); /* interrupts are now disabled */
/* ... */
local_irq_restore(flags); /* interrupts are restored to their previous state */

Disabling a Specific Interrupt Line ?
void disable_irq(unsigned int irq);
void disable_irq_nosync(unsigned int irq);
void enable_irq(unsigned int irq);
void synchronize_irq(unsigned int irq);

Status of the Interrupt System ?
	The macro irqs_disabled(), defined in <asm/system.h>, returns nonzero if the interrupt system on the local processor is disabled. 
	Otherwise, it returns zero.

kernel's current context ?

	in_interrupt()
	in_irq()

Function 		Description
local_irq_disable() 	Disables local interrupt delivery
local_irq_enable() 	Enables local interrupt delivery
local_irq_save() 	Saves the current state of local interrupt delivery and then disables it
local_irq_restore() 	Restores local interrupt delivery to the given state
disable_irq() 		Disables the given interrupt line and ensures no handler on the line is executing before returning
disable_irq_nosync() 	Disables the given interrupt line
enable_irq() 		Enables the given interrupt line
irqs_disabled() 	Returns nonzero if local interrupt delivery is disabled; otherwise returns zero
in_interrupt() 		Returns nonzero if in interrupt context and zero if in process context
in_irq() 		Returns nonzero if currently executing an interrupt handler and zero otherwis

Note : The interrupt handler is normally static because it is never called directly from another file.

conclusion :
Work performed in interrupts includes:

    Acknowledging and resetting hardware
    Copying data from the device to main memory and vice versa
    Processing hardware requests
    Sending out new hardware requests

The kernel provides interfaces for:

    Registering and unregistering interrupt handlers
    Disabling interrupts
    Masking out interrupt lines
    Checking the status of the interrupt system


workqueue :
http://playopensuse.blogspot.in/2015/04/workqueue-mechanism-in-linux.html
https://lwn.net/Articles/23634/

Driver implementation :

Initialization
--------------
Set your gpio pin value: 0 or 1
Set your pin type, such as input or output
Set your interrupt type, such as trigger on rising edge, low level, high level, ...
If these are not set, they will take default values
Initialize your interrupt using: request_irq()


Opening Driver
--------------
When the driver is opened, enable your interrupt


Interrupt Handler
-----------------
Disable interrupt
Clear interrupt
Perform the work (best done by scheduling it to be done after exiting interrupt handler)
Enable interrupt


Close Driver
------------
Disable interrupt


Exit
----
Call free_irq()
